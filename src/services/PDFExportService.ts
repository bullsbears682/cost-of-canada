import jsPDF from 'jspdf';
import html2canvas from 'html2canvas';
import { format } from 'date-fns';
import { UserProfile, SavedCalculation } from './UserProfileService';

export interface ExportData {
  title: string;
  subtitle?: string;
  data: Record<string, any>;
  calculations?: Record<string, any>;
  userInfo?: {
    name?: string;
    email?: string;
    location?: string;
  };
  metadata?: {
    exportDate?: string;
    calculationType?: string;
    notes?: string;
  };
}

export class PDFExportService {
  private static readonly COLORS = {
    primary: '#1e40af',
    secondary: '#059669', 
    accent: '#dc2626',
    text: '#1f2937',
    lightText: '#6b7280',
    background: '#f9fafb',
    border: '#e5e7eb'
  };

  private static readonly FONTS = {
    heading: 'helvetica',
    body: 'helvetica',
    mono: 'courier'
  };

  // Main export function
  static async exportToPDF(data: ExportData, filename?: string): Promise<void> {
    try {
      const pdf = new jsPDF('p', 'mm', 'a4');
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();
      const margin = 20;
      const contentWidth = pageWidth - (margin * 2);
      
      let yPosition = margin;

      // Add header with branding
      yPosition = this.addHeader(pdf, yPosition, pageWidth, data);
      
      // Add title and subtitle
      yPosition = this.addTitle(pdf, yPosition, contentWidth, margin, data);
      
      // Add user info if available
      if (data.userInfo) {
        yPosition = this.addUserInfo(pdf, yPosition, contentWidth, margin, data.userInfo);
      }
      
      // Add main content
      yPosition = this.addMainContent(pdf, yPosition, contentWidth, margin, data);
      
      // Add calculations if available
      if (data.calculations) {
        yPosition = this.addCalculations(pdf, yPosition, contentWidth, margin, data.calculations, pageHeight);
      }
      
      // Add footer
      this.addFooter(pdf, pageHeight, pageWidth, data.metadata?.exportDate || new Date().toISOString());
      
      // Generate filename
      const finalFilename = filename || this.generateFilename(data);
      
      // Save the PDF
      pdf.save(finalFilename);
      
    } catch (error) {
      console.error('Error generating PDF:', error);
      throw new Error('Failed to generate PDF export');
    }
  }

  // Export calculation results
  static async exportCalculation(
    calculationType: string,
    calculationName: string,
    parameters: Record<string, any>,
    results: Record<string, any>,
    userInfo?: { name?: string; email?: string; location?: string }
  ): Promise<void> {
    const exportData: ExportData = {
      title: calculationName,
      subtitle: `${calculationType.charAt(0).toUpperCase() + calculationType.slice(1)} Calculation Report`,
      data: parameters,
      calculations: results,
      userInfo,
      metadata: {
        exportDate: new Date().toISOString(),
        calculationType,
        notes: 'Generated by MapleMetrics - Canadian Cost of Living Analysis'
      }
    };

    await this.exportToPDF(exportData);
  }

  // Export user profile with saved calculations
  static async exportUserProfile(
    profile: UserProfile,
    savedCalculations: SavedCalculation[]
  ): Promise<void> {
    const exportData: ExportData = {
      title: 'User Profile & Calculation History',
      subtitle: 'MapleMetrics Account Summary',
      data: {
        'Display Name': profile.display_name || 'Not set',
        'Email': profile.email || 'Not set',
        'Current Province': profile.location_preferences?.current_province || 'Not set',
        'Current City': profile.location_preferences?.current_city || 'Not set',
        'Annual Income': profile.financial_profile?.annual_income ? 
          `$${profile.financial_profile.annual_income.toLocaleString()} CAD` : 'Not set',
        'Current Savings': profile.financial_profile?.current_savings ? 
          `$${profile.financial_profile.current_savings.toLocaleString()} CAD` : 'Not set',
        'Household Size': profile.financial_profile?.household_size || 'Not set',
        'Member Since': profile.created_at ? format(new Date(profile.created_at), 'MMMM yyyy') : 'Unknown',
        'Total Saved Calculations': savedCalculations.length
      },
      calculations: this.formatSavedCalculations(savedCalculations),
      userInfo: {
        name: profile.display_name,
        email: profile.email,
        location: profile.location_preferences?.current_city && profile.location_preferences?.current_province ?
          `${profile.location_preferences.current_city}, ${profile.location_preferences.current_province}` : undefined
      },
      metadata: {
        exportDate: new Date().toISOString(),
        calculationType: 'profile',
        notes: 'Complete user profile and calculation history export'
      }
    };

    await this.exportToPDF(exportData, `MapleMetrics_Profile_${format(new Date(), 'yyyy-MM-dd')}.pdf`);
  }

  // Export from HTML element (for complex calculations with charts)
  static async exportElementToPDF(
    elementId: string,
    filename: string,
    title: string,
    subtitle?: string
  ): Promise<void> {
    try {
      const element = document.getElementById(elementId);
      if (!element) {
        throw new Error(`Element with ID '${elementId}' not found`);
      }

      // Capture the element as canvas
      const canvas = await html2canvas(element, {
        scale: 2,
        useCORS: true,
        allowTaint: true,
        backgroundColor: '#ffffff'
      });

      const imgData = canvas.toDataURL('image/png');
      const pdf = new jsPDF('p', 'mm', 'a4');
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();
      const margin = 20;
      
      // Add header
      let yPosition = this.addHeader(pdf, margin, pageWidth, { title, subtitle });
      
      // Calculate image dimensions to fit page
      const imgWidth = pageWidth - (margin * 2);
      const imgHeight = (canvas.height * imgWidth) / canvas.width;
      
      // Check if image fits on page, otherwise scale it
      const maxHeight = pageHeight - yPosition - margin - 20; // Leave space for footer
      const finalHeight = Math.min(imgHeight, maxHeight);
      const finalWidth = (canvas.width * finalHeight) / canvas.height;
      
      // Center the image
      const xPosition = (pageWidth - finalWidth) / 2;
      
      // Add the image
      pdf.addImage(imgData, 'PNG', xPosition, yPosition, finalWidth, finalHeight);
      
      // Add footer
      this.addFooter(pdf, pageHeight, pageWidth, new Date().toISOString());
      
      pdf.save(filename);
      
    } catch (error) {
      console.error('Error exporting element to PDF:', error);
      throw new Error('Failed to export element to PDF');
    }
  }

  // Private helper methods
  private static addHeader(pdf: jsPDF, yPosition: number, pageWidth: number, data: ExportData): number {
    // Add logo area (placeholder for now)
    pdf.setFillColor(this.COLORS.primary);
    pdf.rect(20, yPosition, pageWidth - 40, 15, 'F');
    
    // Add MapleMetrics branding
    pdf.setTextColor(255, 255, 255);
    pdf.setFontSize(16);
    pdf.setFont(this.FONTS.heading, 'bold');
    pdf.text('MapleMetrics', 25, yPosition + 10);
    
    // Add tagline
    pdf.setFontSize(8);
    pdf.setFont(this.FONTS.body, 'normal');
    pdf.text('Canadian Cost of Living Analysis', pageWidth - 25, yPosition + 10, { align: 'right' });
    
    return yPosition + 25;
  }

  private static addTitle(pdf: jsPDF, yPosition: number, contentWidth: number, margin: number, data: ExportData): number {
    pdf.setTextColor(this.COLORS.text);
    pdf.setFontSize(20);
    pdf.setFont(this.FONTS.heading, 'bold');
    
    const titleLines = pdf.splitTextToSize(data.title, contentWidth);
    pdf.text(titleLines, margin, yPosition);
    yPosition += titleLines.length * 8;
    
    if (data.subtitle) {
      yPosition += 5;
      pdf.setFontSize(12);
      pdf.setFont(this.FONTS.body, 'normal');
      pdf.setTextColor(this.COLORS.lightText);
      const subtitleLines = pdf.splitTextToSize(data.subtitle, contentWidth);
      pdf.text(subtitleLines, margin, yPosition);
      yPosition += subtitleLines.length * 6;
    }
    
    return yPosition + 10;
  }

  private static addUserInfo(pdf: jsPDF, yPosition: number, contentWidth: number, margin: number, userInfo: any): number {
    pdf.setFontSize(10);
    pdf.setFont(this.FONTS.body, 'bold');
    pdf.setTextColor(this.COLORS.text);
    pdf.text('Generated for:', margin, yPosition);
    
    yPosition += 6;
    pdf.setFont(this.FONTS.body, 'normal');
    pdf.setTextColor(this.COLORS.lightText);
    
    if (userInfo.name) {
      pdf.text(`Name: ${userInfo.name}`, margin + 5, yPosition);
      yPosition += 5;
    }
    if (userInfo.email) {
      pdf.text(`Email: ${userInfo.email}`, margin + 5, yPosition);
      yPosition += 5;
    }
    if (userInfo.location) {
      pdf.text(`Location: ${userInfo.location}`, margin + 5, yPosition);
      yPosition += 5;
    }
    
    return yPosition + 10;
  }

  private static addMainContent(pdf: jsPDF, yPosition: number, contentWidth: number, margin: number, data: ExportData): number {
    pdf.setFontSize(12);
    pdf.setFont(this.FONTS.body, 'bold');
    pdf.setTextColor(this.COLORS.text);
    pdf.text('Input Parameters:', margin, yPosition);
    yPosition += 8;
    
    pdf.setFontSize(9);
    pdf.setFont(this.FONTS.body, 'normal');
    pdf.setTextColor(this.COLORS.lightText);
    
    for (const [key, value] of Object.entries(data.data)) {
      const displayValue = typeof value === 'number' && key.toLowerCase().includes('income') || key.toLowerCase().includes('cost') || key.toLowerCase().includes('price') || key.toLowerCase().includes('savings') ?
        `$${value.toLocaleString()} CAD` : String(value);
      
      const line = `${key}: ${displayValue}`;
      const lines = pdf.splitTextToSize(line, contentWidth - 10);
      pdf.text(lines, margin + 5, yPosition);
      yPosition += lines.length * 5;
    }
    
    return yPosition + 10;
  }

  private static addCalculations(pdf: jsPDF, yPosition: number, contentWidth: number, margin: number, calculations: any, pageHeight: number): number {
    // Check if we need a new page
    if (yPosition > pageHeight - 80) {
      pdf.addPage();
      yPosition = 30;
    }
    
    pdf.setFontSize(12);
    pdf.setFont(this.FONTS.body, 'bold');
    pdf.setTextColor(this.COLORS.text);
    pdf.text('Results & Analysis:', margin, yPosition);
    yPosition += 8;
    
    pdf.setFontSize(9);
    pdf.setFont(this.FONTS.body, 'normal');
    
    for (const [key, value] of Object.entries(calculations)) {
      // Check if we need a new page
      if (yPosition > pageHeight - 40) {
        pdf.addPage();
        yPosition = 30;
      }
      
      let displayValue: string;
      if (typeof value === 'number') {
        if (key.toLowerCase().includes('percent') || key.toLowerCase().includes('rate')) {
          displayValue = `${value.toFixed(2)}%`;
        } else if (key.toLowerCase().includes('income') || key.toLowerCase().includes('cost') || key.toLowerCase().includes('price') || key.toLowerCase().includes('payment') || key.toLowerCase().includes('savings')) {
          displayValue = `$${value.toLocaleString()} CAD`;
        } else {
          displayValue = value.toLocaleString();
        }
      } else {
        displayValue = String(value);
      }
      
      const line = `${key}: ${displayValue}`;
      const lines = pdf.splitTextToSize(line, contentWidth - 10);
      pdf.text(lines, margin + 5, yPosition);
      yPosition += lines.length * 5;
    }
    
    return yPosition;
  }

  private static addFooter(pdf: jsPDF, pageHeight: number, pageWidth: number, exportDate: string): void {
    const footerY = pageHeight - 15;
    
    pdf.setFontSize(8);
    pdf.setFont(this.FONTS.body, 'normal');
    pdf.setTextColor(this.COLORS.lightText);
    
    // Left side - export date
    pdf.text(`Generated: ${format(new Date(exportDate), 'MMM dd, yyyy HH:mm')}`, 20, footerY);
    
    // Right side - website
    pdf.text('MapleMetrics.com', pageWidth - 20, footerY, { align: 'right' });
    
    // Center - disclaimer
    const disclaimer = 'This report is for informational purposes only. Please consult with financial professionals for advice.';
    const disclaimerLines = pdf.splitTextToSize(disclaimer, pageWidth - 40);
    const disclaimerY = footerY - (disclaimerLines.length * 3);
    pdf.text(disclaimerLines, pageWidth / 2, disclaimerY, { align: 'center' });
  }

  private static formatSavedCalculations(calculations: SavedCalculation[]): Record<string, any> {
    const formatted: Record<string, any> = {};
    
    calculations.forEach((calc, index) => {
      const key = `${index + 1}. ${calc.name} (${format(new Date(calc.created_at), 'MMM dd, yyyy')})`;
      formatted[key] = `Type: ${calc.type.replace('_', ' ')}, Parameters: ${Object.keys(calc.parameters).length} items`;
    });
    
    return formatted;
  }

  private static generateFilename(data: ExportData): string {
    const date = format(new Date(), 'yyyy-MM-dd');
    const type = data.metadata?.calculationType || 'report';
    const cleanTitle = data.title.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 30);
    
    return `MapleMetrics_${type}_${cleanTitle}_${date}.pdf`;
  }

  // Utility method to create a quick export button
  static createExportButton(
    elementId: string,
    data: ExportData,
    buttonText: string = 'Export PDF'
  ): HTMLButtonElement {
    const button = document.createElement('button');
    button.textContent = buttonText;
    button.className = 'bg-primary text-white px-4 py-2 rounded hover:bg-primary/90 transition-colors';
    
    button.onclick = async () => {
      button.disabled = true;
      button.textContent = 'Generating PDF...';
      
      try {
        await this.exportToPDF(data);
        button.textContent = 'PDF Generated!';
        setTimeout(() => {
          button.textContent = buttonText;
          button.disabled = false;
        }, 2000);
      } catch (error) {
        button.textContent = 'Export Failed';
        setTimeout(() => {
          button.textContent = buttonText;
          button.disabled = false;
        }, 2000);
      }
    };
    
    return button;
  }
}